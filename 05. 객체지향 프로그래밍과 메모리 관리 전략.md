# 📘 5일차 TIL: 객체지향 프로그래밍과 메모리 관리 전략

## 1. 프로그램의 근본: 코드(Instruction) + 데이터(Data)

컴퓨터 입장에서 프로그램은 **"무엇을 할 것인가(코드)"**와 **"무엇을 가지고 할 것인가(데이터)"**의 결합입니다.

* **코드 영역:** CPU가 실행할 명령어들이 저장되는 읽기 전용 공간.
* **데이터 영역:** 프로그램이 실행되면서 참조하고 수정하는 값들이 저장되는 공간.

---

## 2. 메모리의 이원화: 스택(Stack) vs 힙(Heap)

데이터가 저장되는 공간은 그 **생명 주기(Life Cycle)**에 따라 두 가지로 나뉩니다.

| 구분 | 스택 (Stack) | 힙 (Heap) |
| --- | --- | --- |
| **관리 방식** | 자동 (함수 호출 시 생성, 종료 시 소멸) | 동적 (필요할 때 할당, GC가 수거) |
| **저장 대상** | 지역 변수, 매개변수, 리턴 주소 | **객체(인스턴스)**, 동적 배열 |
| **장점** | 속도가 매우 빠름 (정적 할당) | 크기 제한이 적고 자유로움 (동적 할당) |
| **단점** | 공간이 제한적임 (Stack Overflow 위험) | 할당/해제 속도가 상대적으로 느림 |

> **왜 객체지향은 힙을 쓰는가?**
> 함수가 종료되어도 객체는 메모리에 남아 다른 곳에서 참조될 수 있어야 하기 때문입니다. 스택에 객체를 넣으면 함수 종료와 동시에 객체가 파괴되어 "유지보수"와 "재사용"이 불가능해집니다.

---

## 3. 소프트웨어 공학의 진화: 유지보수 비용의 전쟁

과거에는 하드웨어가 비싸서 **'재사용(함수화)'**이 목표였으나, 현대에는 개발자의 인건비와 시간이 더 비싸기 때문에 **'유지보수(변경 용이성)'**가 최우선입니다.

* **유지보수 = 기존 코드 이해 + 새로운 변경 사항 반영**
* **객체지향의 해답:** 변화가 일어날 때 그 여파가 프로그램 전체로 퍼지지 않도록 **"변화에 둔감한 구조"**를 만드는 것. 이것이 곧 **응집도를 높이고 결합도를 낮추는** 작업입니다.

---

## 4. 객체지향의 3대 특징 상세 설명

### ① 캡슐화 (Encapsulation)

* **개념:** 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 하나로 묶고, 내부의 상세한 구현을 외부로부터 숨기는 것.
* **왜 하는가?** 외부에서 직접 데이터를 건드리면 데이터가 오염될 수 있습니다. (예: `player.hp = -100` 같은 논리적 오류 방지)
* **방법:** 파이썬에서는 관례적으로 언더바(`_` 또는 `__`)를 변수 앞에 붙여 직접 접근을 경고하고, 메서드를 통해서만 수정하게 합니다.

### ② 추상화 (Abstraction)

* **개념:** 복잡한 내부 로직은 감추고, 사용자에게는 필요한 **기능(인터페이스)**만 보여주는 것.
* **예시:** 운전자는 엔진의 피스톤 운동 원리(내부 로직)를 몰라도 핸들과 페달(인터페이스)만 알면 운전할 수 있는 것과 같습니다.

### ③ 다형성 (Polymorphism)

* **개념:** 이름은 같지만 내부 동작은 다르게 설계하는 것.
* **예시:** `move()`라는 메서드가 있을 때, `Player`는 걷고, `Enemy`는 날아가고, `NPC`는 멈춰있게 구현할 수 있습니다. 호출하는 쪽에서는 어떤 객체든 상관없이 그냥 `.move()`만 부르면 되므로 코드가 매우 간결해집니다.

---

## 5. 클래스, 인스턴스, 그리고 `__init__`의 비밀

### 클래스 (Class) = 설계도

* 클래스는 메모리에 실체가 없습니다. "이런 형태의 객체를 만들겠다"는 정의일 뿐입니다.
* 붕어빵 틀에 비유됩니다.

### 인스턴스 (Instance) = 실체

* `pobj = Player()`라고 실행하는 순간, **힙(Heap) 메모리**에 해당 객체의 공간이 할당됩니다.
* 이때 만들어진 실체를 인스턴스라고 부르며, `pobj`는 그 주소값을 들고 있는 **참조 변수**입니다.

### `__init__` (생성자/초기화 함수)

* 객체가 메모리에 할당되자마자 자동으로 호출됩니다.
* **중요한 이유:** 객체마다 서로 다른 상태값(좌표, 이름 등)을 가져야 하므로, 메모리 공간이 생기자마자 그 공간에 초기값을 채워 넣는 역할을 합니다.

---

## 6. 객체지향의 단점과 해결책

* **단점:** 객체는 함수보다 **무겁습니다.** 함수는 명령어 주소만 있으면 되지만, 객체는 속성값들을 저장할 메모리 공간과 메서드에 대한 참조 정보를 모두 가져야 하기 때문입니다.
* **메모리 누수 위험:** 힙을 쓰기 때문에 제때 지우지 않으면 메모리가 가득 찹니다(Memory Leak).
* **해결책 (가비지 컬렉터):** 파이썬은 똑똑하게도 아무도 참조하지 않는(주소값을 잃어버린) 객체를 알아서 찾아내 메모리에서 지워줍니다.

---

## 7. 실습 코드 리뷰 및 보완

```python
import random

class Enemy:
    def __init__(self):
        # 1. 속성(변수): 데이터를 저장하는 공간
        self.x = random.randint(0, 800)
        self.y = random.randint(0, 600)
        self.myShape = 'Enemy'
        
    def display(self):
        # 2. self의 역할: 메모리 어딘가에 있는 '내(인스턴스)' 주소를 찾아가서 내 x, y를 꺼내옴
        print(f"위치: ({self.x}, {self.y})", self)
    
    def moveDown(self, distance):
        # 3. 기능(메서드): 데이터를 변경하는 코드
        self.y += distance
        self.display()

# 사용 예시
e1 = Enemy() # e1이라는 참조 변수가 힙 메모리의 첫 번째 적을 가리킴
e2 = Enemy() # e2는 또 다른 위치의 힙 메모리를 가리킴

```

* **핵심 포인트:** `e1`과 `e2`는 같은 설계도(Class)로 만들어졌지만, 힙 메모리에서는 **전혀 다른 주소**를 점유하며 각자의 `x, y` 값을 가집니다. 이것이 객체지향이 데이터를 관리하는 방식입니다.
