# 📘 7일차 TIL: 객체지향 심화 및 정규표현식

## 1. 클래스 상속: "반복되는 코드를 부모에게 맡겨라"

상속은 쉽게 말해 **"공통 설계도는 부모가 만들고, 자식은 차이점만 추가하는 것"**입니다.

### 💡 왜 상속을 하나요?

1. **중복 제거:** 100종류의 유닛이 모두 '위치(x, y)'가 있다면, 100번 쓸 필요 없이 부모인 `Character`에 한 번만 쓰면 됩니다.
2. **일괄 관리(Upcasting):** "모든 캐릭터는 화면에 그려져야 한다"면, 개별 캐릭터가 아닌 `Character`라는 이름으로 묶어서 한 번에 명령을 내릴 수 있습니다.

---

## 2. 캡슐화와 Getter/Setter: "금고와 열쇠"

학습하신 코드에서 `self.__x`처럼 변수 앞에 언더바 두 개(`__`)를 붙이는 것을 **캡슐화**라고 합니다.

### 💡 Getter와 Setter는 왜 쓰나요?

* **Getter (getX):** 변수값을 읽어오는 열쇠.
* **Setter (setX):** 변수값을 안전하게 수정하는 열쇠.

**"자식 클래스에서 쓰려고 만드는 건가요?"**라는 질문에 대한 답은 **"안전성 때문"**입니다.

* **예시:** 게임 캐릭터의 x좌표가 -500이 되면 화면 밖으로 사라집니다. 만약 외부에서 `player.x = -500`이라고 직접 바꾸면 오류가 나겠죠?
* 하지만 `setX(-500)`이라는 함수를 통해 바꾸게 하면, 함수 내부에서 **"값이 0보다 작으면 0으로 고정해!"**라는 안전장치(if문)를 걸 수 있습니다.

---

## 3. `self`의 정체: "나는 누구인가?"

가장 헷갈리는 `self`는 **"지금 이 코드를 실행하고 있는 바로 그 객체"**를 가리킵니다.

### 💡 이해를 돕는 비유

붕어빵 틀(클래스)로 붕어빵 2개를 구웠습니다.

1. **붕어빵 A (인스턴스 1):** 팥이 들어있음
2. **붕어빵 B (인스턴스 2):** 슈크림이 들어있음

만약 `먹기()`라는 함수가 실행될 때, `self.속내용`이라고 써야만 **A는 팥**을 꺼내고, **B는 슈크림**을 꺼낼 수 있습니다. `self`가 없다면 컴퓨터는 어떤 붕어빵의 속을 꺼내야 할지 모릅니다.

---

## 4. 실습 코드 (상속 + 캡슐화 + self 총정리)

```python
import random

# 1. 부모 클래스 (공통 기능)
class Character:
    def __init__(self):
        # __를 붙여 외부에서 직접 수정을 막음 (캡슐화)
        self.__x = random.randint(0, 800)
        self.__y = random.randint(0, 800)

    def getX(self): return self.__x
    
    def setX(self, value):
        # 안전장치: 0~800 사이로만 좌표가 설정되게 함
        if value < 0: self.__x = 0
        elif value > 800: self.__x = 800
        else: self.__x = value

    def display(self):
        # self.__x는 '나의 x'를 의미함
        print(f"좌표: ({self.__x}, {self.__y})")

# 2. 자식 클래스 (상속)
class Player(Character):
    def display(self):
        # super()는 부모 클래스를 의미함
        super().display() 
        print("-> 플레이어 상태입니다.")

class Enemy(Character):
    def moveLeft(self, dist):
        # 부모의 __x에 직접 접근 못하므로 Getter/Setter 사용
        current_x = self.getX()
        self.setX(current_x - dist)
        print(f"적군 이동 완료!")

# 실행부
p1 = Player()
p1.display() # 부모의 기능 + 내 기능 실행

e1 = Enemy()
e1.moveLeft(10)

```

---

## 5. 정규표현식: "복잡한 문자열 찾기 끝판왕"

정규표현식은 일종의 **'문자열 검색 패턴'**입니다. 복잡한 `if`문과 `split`을 단 한 줄로 줄여줍니다.

### 🔍 메타 문자 핵심 요약 (암기 팁!)

* `\d`: **D**igit(숫자)를 의미합니다.
* `{n}`: n번 반복한다는 뜻입니다. `\d{6}`은 "숫자 6개"입니다.
* `[]`: "이 중 하나"라는 뜻입니다. `[abc]`는 a, b, c 중 하나를 찾습니다.
* `[^]`: "얘네는 빼고"라는 뜻입니다. `[^abc]`는 a, b, c가 아닌 것을 찾습니다.
* `()` : **그룹**입니다. 나중에 `\1` 같은 기호로 다시 불러와서 사용할 수 있습니다.

### 🔍 코드 비교 (주민번호 마스킹)

**[기존 방식]** : 글자 세고, 자르고, 숫자인지 검사하고... (매우 복잡)
**[정규표현식]** : `(\d{6})-\d{7}` 패턴을 찾아서 앞 그룹(`\1`)만 남기고 뒤는 `*******`로 바꿔! (매우 간단)

```python
import re

data = "park 800101-1234567"
# 패턴 설명: (숫자6개)를 1번 그룹으로 묶고, 뒤에 -와 숫자7개가 붙은 패턴
pattern = r'(\d{6})-\d{7}'

# \1은 1번 그룹(생년월일)을 그대로 쓰겠다는 뜻입니다.
result = re.sub(pattern, r'\1-*******', data)
print(result) # 출력: park 800101-*******

```
